Mitch Lindsey




parser and scanner - returns a tree based on BNF:

< program >    ->      <vars> <block>
< block >      ->      Begin <vars> <stats> End
< vars >       ->      empty | INT Identifier Integer <vars>
< expr >       ->      <A> <K>
< k >          ->      + <expr> | - <expr> | empty
< a >          ->      <N> * <A> | <N>
< n >          ->      <M> / <N> | <M>
< m >          ->      - <M> |  <R>
< r >          ->      [ <expr> ] | Identifier | Integer
< stats >      ->      <stat> : <mStat>
< mStat >      ->      empty |  <stat>  :  <mStat>
< stat >       ->      <in> | <out> | <block> | <if> | <loop> | <assign>
< in >         ->      Read [ Identifier ]
< out >        ->      Output [ <expr> ]
< if >         ->      IFF [ <expr> <ro> <expr> ] <stat>
< loop >       ->      Loop [ <expr> <ro> <expr> ] <stat>
< assign >     ->      Identifier  = <expr>
< ro >         ->      < | = <  | >  | = > | =  =  |   =


<mStat>, <vars> return NULL if empty



Lexical Definitions

Case sensitive
Each scanner error should display "Scanner Error:" followed by details including the line number if counted
Alphabet
    all English letters (upper and lower), digits, plus the extra characters as seen below, plus WS
    No other characters allowed and they should generate errors
Identifiers
    begin with a an upper case letter and
    continue with any number of letters or digits
    you may assume no identifier is longer than 8 characters
Keywords (reserved, suggested individual tokens)
    Begin  End Loop Void INT Return Read Output Program IFF  Then Let
Operators and delimiters group
    =  <  >  :   +  -  *  /   %  . (  ) , { } ; [ ]
Integers
    any sequence of decimal digits, no sign, no decimal point
    you may assume no number longer than 8 characters
Comments start with \ and end with new line